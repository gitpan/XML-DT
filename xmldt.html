<HTML>
<HEAD>
<TITLE>XML::DT - a package for down translation of XML to strings</TITLE>
<LINK REV="made" HREF="mailto:root@porky.devel.redhat.com">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<UL>

		<LI><A HREF="#C_inctxt_function">&lt;CODE&gt;inctxt&lt;/CODE&gt; function</A>
		<LI><A HREF="#User_provided_element_processing">User provided element processing functions</A>
		<LI><A HREF="#C_default_function">&lt;CODE&gt;-default&lt;/CODE&gt; function</A>
		<LI><A HREF="#C_outputenc_option">&lt;CODE&gt;-outputenc&lt;/CODE&gt; option</A>
		<LI><A HREF="#C_inputenc_option">&lt;CODE&gt;-inputenc&lt;/CODE&gt; option</A>
		<LI><A HREF="#C_pcdata_function">&lt;CODE&gt;-pcdata&lt;/CODE&gt; function</A>
		<LI><A HREF="#C_begin_function">&lt;CODE&gt;-begin&lt;/CODE&gt; function</A>
		<LI><A HREF="#C_end_function">&lt;CODE&gt;-end&lt;/CODE&gt; function</A>
		<LI><A HREF="#C_toxml_function">&lt;CODE&gt;toxml&lt;/CODE&gt; function</A>
	</UL>

	<LI><A HREF="#Elements_with_values_other_than_">Elements with values other than strings (C&lt;-type))</A>
	<UL>

		<LI><A HREF="#An_example_">An example:</A>
	</UL>

	<LI><A HREF="#DT_Skeleton_generation">DT Skeleton generation</A>
	<LI><A HREF="#DTD_skeleton_generation">DTD skeleton generation</A>
	<LI><A HREF="#BUGS">BUGS</A>
	<LI><A HREF="#Author">Author</A>
	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#Bugs">Bugs</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
<PRE>    XML::DT - a package for down translation of XML to strings
</PRE>
<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<PRE>    use XML::DT;
</PRE>
<P>
<PRE>    %xml=( 'music'    =&gt; sub{&quot;Music from: $c\n&quot;},
           'lyrics'   =&gt; sub{&quot;Lyrics from:$c\n (the value of attribute
                               IN is:$v{IN}\n)&quot;},
           'title'    =&gt; sub{ uc($c) },
           '-default' =&gt; sub{&quot;$q:$c&quot;},
           '-outputenc' =&gt; 'ISO-8859-1');
    
    print dt($filename,%xml);
</PRE>
<P>
<PRE>    print dtstring(&quot;&lt;arq&gt;
                    &lt;title&gt;Vejam Bem&lt;/title&gt;
                    &lt;music&gt;Zeca Afonso&lt;/music&gt;
                    &lt;/arq&gt;&quot;,%xml);
</PRE>
<P>
<PRE>    inctxt('music/lyrics')
    inctxt('music.*')
</PRE>
<P>
<PRE>    ctxt(1)       /* the father element */
</PRE>
<P>
<PRE>    mkdtskel($file)
    mkdtdskel($file)
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
This module processes XML files with an approach similar to OMNIMARK.

<P>
Down translation function <CODE>dt</CODE> receives a filename and a set of expressions (functions) defining the
processing and associated values for each element.

<P>
<CODE>dtstring</CODE> is similar but takes input from a string instead of a file.

<P>
<HR>
<H2><A NAME="C_inctxt_function">&lt;CODE&gt;inctxt&lt;/CODE&gt; function</A></H2>
<P>
<CODE>inctxt(pattern)</CODE> is true if the actual element path matches the provided pattern. This
function is ment to be used in the element functions in order to achive
context dependent processing. 

<P>
<HR>
<H2><A NAME="User_provided_element_processing">User provided element processing functions</A></H2>
<P>
The user must provide an HASH with a function for each element, that
computes element output. Functions can use the element name <CODE>$q</CODE>, the element content <CODE>$c</CODE> and the atribute values hash <CODE>%v</CODE>. 

<P>
All those global variables are defined in <CODE>$CALLER::</CODE>.

<P>
Each time an element is find the associated function is called.

<P>
Content is calculated by concatenation of element contents strings and
interior elements return values.

<P>
<HR>
<H2><A NAME="C_default_function">&lt;CODE&gt;-default&lt;/CODE&gt; function</A></H2>
<P>
When a element has no associated function, the function associated with 
<CODE>-default</CODE> called. If no <CODE>-default</CODE> function is defined the default function returns a XML like string for the
elemente.

<P>
<HR>
<H2><A NAME="C_outputenc_option">&lt;CODE&gt;-outputenc&lt;/CODE&gt; option</A></H2>
<P>
<CODE>-outputenc</CODE> defines the output encoding (default is Unicode UTF8).

<P>
<HR>
<H2><A NAME="C_inputenc_option">&lt;CODE&gt;-inputenc&lt;/CODE&gt; option</A></H2>
<P>
<CODE>-inputenc</CODE> forces a input encoding type. Whenever that is possible, define the input
encoding in the XML file:

<P>
<PRE>   &lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;
</PRE>
<P>
<HR>
<H2><A NAME="C_pcdata_function">&lt;CODE&gt;-pcdata&lt;/CODE&gt; function</A></H2>
<P>
<CODE>-pcdata</CODE> function is used to define tranformation over the contents. Typically this
function should look at context (see <CODE>inctxt</CODE> function)

<P>
The default <CODE>-pcdata</CODE> function is the identity

<P>
<HR>
<H2><A NAME="C_begin_function">&lt;CODE&gt;-begin&lt;/CODE&gt; function</A></H2>
<P>
Function to be executed before processing XML file.

<P>
Example of use: inicialization of sife-effect variables

<P>
<HR>
<H2><A NAME="C_end_function">&lt;CODE&gt;-end&lt;/CODE&gt; function</A></H2>
<P>
Function to be executed after processing XML file. I can use <CODE>$c</CODE> content value. The value returned by <CODE>-end</CODE> will be the <CODE>dt</CODE> return value.

<P>
Example of use: post-processing of returned contents 

<P>
<HR>
<H2><A NAME="C_toxml_function">&lt;CODE&gt;toxml&lt;/CODE&gt; function</A></H2>
<P>
This is the default ``-default'' function. It can be used to generate xml
based on <CODE>$c</CODE>  <CODE>$q</CODE> and <CODE>%v</CODE> variables. Example: add a new attribute to element <CODE>ele1</CODE> without changing it:

<P>
<PRE>  %handler=( ...
             ele1 =&gt; sub { $v{at1} = &quot;v1&quot;; toxml(); },
           )
</PRE>
<P>
<HR>
<H1><A NAME="Elements_with_values_other_than_">Elements with values other than strings (C&lt;-type))</A></H1>
<P>
By default all elements return strings, and contents (<CODE>$c</CODE>) is the concatenation of the strings returned by the sub-elements.

<P>
In some situations the XML text contains values that are better processed
as a structured type.

<P>
The following types (functors) are available:

<P>
<PRE>     STR  -&gt; concatenates all the subelements returned values (DEFAULT)
          all the subelement sould return strings to be concatenated
     SEQ  -&gt; makes an ARRAY with all the sub elements contents; attritutes are
          ignored (they should be processed in the subelement). (returns a ref)
     SEQH -&gt; makes an ARRAY of HASH with all the sub elements (returns a ref);
          for each subelement: 
                 -q  =&gt; element name
                 -c  =&gt; contents
                 at1 =&gt; at value1    for each atribute
     MAP  -&gt; makes an HASH with the sub elements; keys are the sub-element
          names, values are their contents. Atributes are ignored. (they should
          be processed in the subelement) (returns a ref)
     MULTIMAP -&gt; makes an HASH of ARRAY; keys are the sub-element names;
         values are lists of contents; atributes are ignored (they should be
         processed in the subelement); (returns a ref)
     MMAPON(elementlist) -&gt; makes an HASH with the subelements; 
          keys are the sub-element names, values are their contents; 
          atributes are ignored (they should be processed in the subelement);
          for all the elements contained in the elementelist, it is created 
          an ARRAY whith their contents. (returns a ref)
</PRE>
<P>
<HR>
<H2><A NAME="An_example_">An example:</A></H2>
<P>
<PRE>   use XML::DT;
   %handler = ( contacts =&gt; sub{ [ split(&quot;;&quot;,$c)] },
                -default =&gt; sub{$c},
                -type    =&gt; { institution =&gt; 'MAP',
                              degrees     =&gt;  MMAPON('name')
                              tels        =&gt; 'SEQ' }
              );
   $a = dt (&quot;f.xml&quot;, %handler);
</PRE>
<P>
with the following f.xml

<P>
<PRE>    &lt;degrees&gt;
     &lt;institution&gt;
      &lt;id&gt;U.M.&lt;/id&gt;
      &lt;name&gt;University of Minho&lt;/name&gt;
      &lt;tels&gt;
        &lt;item&gt;1111&lt;/item&gt; 
        &lt;item&gt;1112&lt;/item&gt;
        &lt;item&gt;1113&lt;/item&gt;
      &lt;/tels&gt;
      &lt;where&gt;Portugal&lt;/where&gt;
      &lt;contacts&gt;J.Joao; J.Rocha; J.Ramalho&lt;/contacts&gt;
     &lt;/institution&gt;
     &lt;name&gt;Computer science&lt;/name&gt;
     &lt;name&gt;informatic &lt;/name&gt;
     &lt;name&gt; history &lt;/name&gt;
    &lt;/degrees&gt;
</PRE>
<P>
would make <CODE>$a</CODE>

<P>
<PRE>  { 'name' =&gt; [ 'Computer science',
                'informatic ',
                ' history ' ],
    'institution' =&gt; { 'tels' =&gt; [ 1111,
                                   1112,
                                   1113 ],
                       'name' =&gt; 'University of Minho',
                       'where' =&gt; 'Portugal',
                       'id' =&gt; 'U.M.',
                       'contacts' =&gt; [ 'J.Joao',
                                       ' J.Rocha',
                                       ' J.Ramalho' ] } };
</PRE>
<P>
<HR>
<H1><A NAME="DT_Skeleton_generation">DT Skeleton generation</A></H1>
<P>
It is possible to build an initial processor program based on an example

<P>
To do this use the function <CODE>mkdtskel(filename)</CODE>.

<P>
Example:

<P>
<PRE>  perl -MXML::DT -e 'mkdtskel &quot;f.xml&quot;' &gt; f.pl
</PRE>
<P>
<HR>
<H1><A NAME="DTD_skeleton_generation">DTD skeleton generation</A></H1>
<P>
It makes a naife DTD based on an <CODE>example(s).</CODE>

<P>
To do this use the function <CODE>mkdtdskel(filename*)</CODE>.

<P>
Example:

<P>
<PRE>  perl -MXML::DT -e 'mkdtdskel &quot;f.xml&quot;' &gt; f.dtd
</PRE>
<P>
<HR>
<H1><A NAME="BUGS">BUGS</A></H1>
<P>
This section is out of date...

<P>
<HR>
<H1><A NAME="Author">Author</A></H1>
<P>
Jose Joao, <A HREF="mailto:jj@di.uminho.pt">jj@di.uminho.pt</A>

<P>
<PRE>  <A HREF="http://www.di.uminho.pt/~jj/perl/XML/">http://www.di.uminho.pt/~jj/perl/XML/</A>
</PRE>
<P>
thanks to 

<P>
<PRE>  Michel Rodriguez &lt;mrodrigu@ieee.org&gt;
  José Carlos Ramanlho &lt;jcr@di.uminho.py&gt;
</PRE>
<P>
<HR>
<H1><A NAME="NAME">NAME</A></H1>
<P>
<CODE>lat1.pm</CODE> - module for unicode utf8 to latin1 translation

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<PRE>   $latin1string = lat1::utf8($utf8string)
</PRE>
<P>
<HR>
<H1><A NAME="Bugs">Bugs</A></H1>
<P>
Translating the laint1 subset of unicode utf8 is very simples and needs no
tables.

<P>
If you need more complex translation, see the perl modules about unicode
and the <CODE>recode</CODE> command.

</BODY>

</HTML>
