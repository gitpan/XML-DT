<HTML>
<HEAD>
<TITLE>XML::DT - a package for down translation of XML to strings</TITLE>
<LINK REV="made" HREF="mailto:root@hostname.di.uminho.pt">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<UL>

		<LI><A HREF="#pathdt function"><CODE>pathdt</CODE> function</A></LI>
		<LI><A HREF="#inctxt function"><CODE>inctxt</CODE> function</A></LI>
		<LI><A HREF="#user provided element processing functions">User provided element processing functions</A></LI>
		<LI><A HREF="#default function"><CODE>-default</CODE> function</A></LI>
		<LI><A HREF="#outputenc option"><CODE>-outputenc</CODE> option</A></LI>
		<LI><A HREF="#inputenc option"><CODE>-inputenc</CODE> option</A></LI>
		<LI><A HREF="#pcdata function"><CODE>-pcdata</CODE> function</A></LI>
		<LI><A HREF="#begin function"><CODE>-begin</CODE> function</A></LI>
		<LI><A HREF="#end function"><CODE>-end</CODE> function</A></LI>
		<LI><A HREF="#toxml function"><CODE>toxml</CODE> function</A></LI>
	</UL>

	<LI><A HREF="#elements with values other than strings (type)">Elements with values other than strings (<CODE>-type</CODE>)</A></LI>
	<UL>

		<LI><A HREF="#an example:">An example:</A></LI>
	</UL>

	<LI><A HREF="#dt skeleton generation">DT Skeleton generation</A></LI>
	<LI><A HREF="#dtd skeleton generation">DTD skeleton generation</A></LI>
	<LI><A HREF="#bugs">BUGS</A></LI>
	<LI><A HREF="#author">Author</A></LI>
	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#bugs">Bugs</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>XML::DT - a package for down translation of XML to strings</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
    use XML::DT;</PRE>
<PRE>
    %xml=( 'music'    =&gt; sub{&quot;Music from: $c\n&quot;},
           'lyrics'   =&gt; sub{&quot;Lyrics from:$c\n (the value of attribute
                               IN is:$v{IN}\n)&quot;},
           'title'    =&gt; sub{ uc($c) },
           '-default' =&gt; sub{&quot;$q:$c&quot;},
           '-outputenc' =&gt; 'ISO-8859-1');
</PRE>
<PRE>

    print dt($filename,%xml);</PRE>
<PRE>
    print dtstring(&quot;&lt;arq&gt;
                    &lt;title&gt;Vejam Bem&lt;/title&gt;
                    &lt;music&gt;Zeca Afonso&lt;/music&gt;
                    &lt;/arq&gt;&quot;,%xml);</PRE>
<PRE>
    inctxt('music/lyrics')
    inctxt('music.*')</PRE>
<PRE>
    ctxt(1)       /* the father element */</PRE>
<PRE>
    mkdtskel($file)
    mkdtdskel($file)</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>This module processes XML files with an approach similar to OMNIMARK.</P>
<P>Down translation function <CODE>dt</CODE> receives a filename and a set of expressions
(functions) defining the processing and associated values for each element.</P>
<P><CODE>dtstring</CODE> is similar but takes input from a string instead of a file.</P>
<P>
<H2><A NAME="pathdt function"><CODE>pathdt</CODE> function</A></H2>
<P>The <CODE>pathdt</CODE> function uses a subset of XPath as key in the handler. Example:</P>
<PRE>
   %handler = (
        &quot;article/title&quot; =&gt; sub{ toxml(&quot;h1&quot;,{},$c) },
        &quot;section/title&quot; =&gt; sub{ toxml(&quot;h2&quot;,{},$c) },
        &quot;title&quot;         =&gt; sub{ $c },
        &quot;//image[@type='jpg']&quot; =&gt; sub{ &quot;JPEG: &lt;img src=\&quot;$c\&quot;&gt;&quot; },
        &quot;//image[@type='bmp']&quot; =&gt; sub{ &quot;BMP: sorry, no bitmaps on the web&quot; },
        ...
  )</PRE>
<PRE>
  pathdt($filename,%handler);</PRE>
<P>Here are some examples of valid XPath expressions under XML::DT:</P>
<PRE>
  /aaa
  /aaa/bbb
  //ccc                           - ccc somewhere (same as &quot;ccc&quot;)
  /*/aaa/*
  //*                             - same as &quot;-default&quot;
  /aaa[@id]                       - aaa with an attribute id
  /*[@*]                          - root with an attribute
  /aaa[not(@name)]                - aaa with no attribute &quot;name&quot;
  //bbb[@name='foo']              - ... attribute &quot;name&quot; = &quot;foo&quot;
  /ccc[normalize-space(@name)='bbb']
  //*[name()='bbb']               - complex way of saying &quot;//bbb&quot;
  //*[starts-with(name(),'aa')]   - an element named &quot;aa.*&quot;
  //*[contains(name(),'c')]       - an element       &quot;.*c.*&quot;
  //aaa[string-length(name())=4]  -                  &quot;....&quot;
  //aaa[string-length(name())&amp;lt;4]                  &quot;.{1,4}&quot;
  //aaa[string-length(name())&amp;gt;5]                  &quot;.{5,}&quot;</PRE>
<P>For more information, visit www.w3c.org or try a tutorial under www.zvon.org</P>
<P>
<H2><A NAME="inctxt function"><CODE>inctxt</CODE> function</A></H2>
<P><CODE>inctxt(pattern)</CODE> is true if the actual element path matches the provided 
pattern. This function is meant to be used in the element functions in order
to achieve context dependent processing.</P>
<P>
<H2><A NAME="user provided element processing functions">User provided element processing functions</A></H2>
<P>The user must provide an HASH with a function for each element,
that computes element output. Functions can use the element name <CODE>$q</CODE>, 
the element content <CODE>$c</CODE> and the attribute values hash <CODE>%v</CODE>.</P>
<P>All those global variables are defined in <CODE>$CALLER::</CODE>.</P>
<P>Each time an element is find the associated function is called.</P>
<P>Content is calculated by concatenation of element contents strings and
interior elements return values.</P>
<P>
<H2><A NAME="default function"><CODE>-default</CODE> function</A></H2>
<P>When a element has no associated function, the function associated with 
<CODE>-default</CODE> called. If no <CODE>-default</CODE> function is defined the default function 
returns a XML like string for the element.</P>
<P>When you use <CODE>/-type</CODE> definitions, you often need do set <CODE>-default</CODE>
function to return just the contents: <CODE>sub{$id}</CODE>.</P>
<P>
<H2><A NAME="outputenc option"><CODE>-outputenc</CODE> option</A></H2>
<P><CODE>-outputenc</CODE> defines the output encoding (default is Unicode UTF8).</P>
<P>
<H2><A NAME="inputenc option"><CODE>-inputenc</CODE> option</A></H2>
<P><CODE>-inputenc</CODE> forces a input encoding type. Whenever that is possible,
define the input encoding in the XML file:</P>
<PRE>
   &lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;</PRE>
<P>
<H2><A NAME="pcdata function"><CODE>-pcdata</CODE> function</A></H2>
<P><CODE>-pcdata</CODE> function is used to define transformation over the contents.
Typically this function should look at context (see <CODE>inctxt</CODE> function)</P>
<P>The default <CODE>-pcdata</CODE> function is the identity</P>
<P>
<H2><A NAME="begin function"><CODE>-begin</CODE> function</A></H2>
<P>Function to be executed before processing XML file.</P>
<P>Example of use: initialization of side-effect variables</P>
<P>
<H2><A NAME="end function"><CODE>-end</CODE> function</A></H2>
<P>Function to be executed after processing XML file.
I can use <CODE>$c</CODE> content value.
The value returned by <CODE>-end</CODE> will be the <CODE>dt</CODE> return value.</P>
<P>Example of use: post-processing of returned contents</P>
<P>
<H2><A NAME="toxml function"><CODE>toxml</CODE> function</A></H2>
<P>This is the default ``-default'' function. It can be used to generate xml
based on <CODE>$c</CODE> <CODE>$q</CODE> and <CODE>%v</CODE> variables. Example: add a new attribute to
element <CODE>ele1</CODE> without changing it:</P>
<PRE>
  %handler=( ...
             ele1 =&gt; sub { $v{at1} = &quot;v1&quot;; toxml(); },
           )</PRE>
<P><CODE>toxml</CODE> can also be used with 3 arguments: tag, attrigutes and contents</P>
<PRE>
  toxml(&quot;a&quot;,{href=&gt; &quot;<A HREF="http://local/f.html&quot">http://local/f.html&quot</A>;}, &quot;example&quot;)</PRE>
<P>returns:</P>
<PRE>
  &lt;a href='<A HREF="http://local/f.html">http://local/f.html</A>'&gt;example&lt;/a&gt;</PRE>
<P>
<HR>
<H1><A NAME="elements with values other than strings (type)">Elements with values other than strings (<CODE>-type</CODE>)</A></H1>
<P>By default all elements return strings, and contents (<CODE>$c</CODE>) is the
concatenation of the strings returned by the sub-elements.</P>
<P>In some situations the XML text contains values that are better processed as
a structured type.</P>
<P>The following types (functors) are available:</P>
<PRE>
     STR  -&gt; concatenates all the subelements returned values (DEFAULT)
          all the subelement should return strings to be concatenated
     SEQ  -&gt; makes an ARRAY with all the sub elements contents; attributes are
          ignored (they should be processed in the subelement). (returns a ref)
     SEQH -&gt; makes an ARRAY of HASH with all the sub elements (returns a ref);
          for each subelement: 
                 -q  =&gt; element name
                 -c  =&gt; contents
                 at1 =&gt; at value1    for each attribute
     MAP  -&gt; makes an HASH with the sub elements; keys are the sub-element
          names, values are their contents. Attributes are ignored. (they should
          be processed in the subelement) (returns a ref)
     MULTIMAP -&gt; makes an HASH of ARRAY; keys are the sub-element names;
         values are lists of contents; attributes are ignored (they should be
         processed in the subelement); (returns a ref)
     MMAPON(elementlist) -&gt; makes an HASH with the subelements; 
          keys are the sub-element names, values are their contents; 
          attributes are ignored (they should be processed in the subelement);
          for all the elements contained in the elementlist, it is created 
          an ARRAY with their contents. (returns a ref)
     ZERO -&gt; don't process the subelements; return &quot;&quot;</PRE>
<P>When you use <CODE>/-type</CODE> definitions, you often need do set <CODE>-default</CODE>
function returning just the contents <CODE>sub{$id}</CODE>.</P>
<P>
<H2><A NAME="an example:">An example:</A></H2>
<PRE>
   use XML::DT;
   %handler = ( contacts =&gt; sub{ [ split(&quot;;&quot;,$c)] },
                -default =&gt; sub{$c},
                -type    =&gt; { institution =&gt; 'MAP',
                              degrees     =&gt;  MMAPON('name')
                              tels        =&gt; 'SEQ' }
              );
   $a = dt (&quot;f.xml&quot;, %handler);</PRE>
<P>with the following f.xml</P>
<PRE>
    &lt;degrees&gt;
     &lt;institution&gt;
      &lt;id&gt;U.M.&lt;/id&gt;
      &lt;name&gt;University of Minho&lt;/name&gt;
      &lt;tels&gt;
        &lt;item&gt;1111&lt;/item&gt; 
        &lt;item&gt;1112&lt;/item&gt;
        &lt;item&gt;1113&lt;/item&gt;
      &lt;/tels&gt;
      &lt;where&gt;Portugal&lt;/where&gt;
      &lt;contacts&gt;J.Joao; J.Rocha; J.Ramalho&lt;/contacts&gt;
     &lt;/institution&gt;
     &lt;name&gt;Computer science&lt;/name&gt;
     &lt;name&gt;Informatica &lt;/name&gt;
     &lt;name&gt; history &lt;/name&gt;
    &lt;/degrees&gt;</PRE>
<P>would make $a</P>
<PRE>
  { 'name' =&gt; [ 'Computer science',
                'Informatica ',
                ' history ' ],
    'institution' =&gt; { 'tels' =&gt; [ 1111,
                                   1112,
                                   1113 ],
                       'name' =&gt; 'University of Minho',
                       'where' =&gt; 'Portugal',
                       'id' =&gt; 'U.M.',
                       'contacts' =&gt; [ 'J.Joao',
                                       ' J.Rocha',
                                       ' J.Ramalho' ] } };</PRE>
<P>
<HR>
<H1><A NAME="dt skeleton generation">DT Skeleton generation</A></H1>
<P>It is possible to build an initial processor program based on an example</P>
<P>To do this use the function <CODE>mkdtskel(filename)</CODE>.</P>
<P>Example:</P>
<PRE>
  perl -MXML::DT -e 'mkdtskel &quot;f.xml&quot;' &gt; f.pl</PRE>
<P>
<HR>
<H1><A NAME="dtd skeleton generation">DTD skeleton generation</A></H1>
<P>It makes a naive DTD based on an example(s).</P>
<P>To do this use the function <CODE>mkdtdskel(filename*)</CODE>.</P>
<P>Example:</P>
<PRE>
  perl -MXML::DT -e 'mkdtdskel &quot;f.xml&quot;' &gt; f.dtd</PRE>
<P>
<HR>
<H1><A NAME="bugs">BUGS</A></H1>
<P>This section is out of date...</P>
<P>
<HR>
<H1><A NAME="author">Author</A></H1>
<P>Jose Joao, <A HREF="mailto:jj@di.uminho.pt">jj@di.uminho.pt</A></P>
<PRE>
  <A HREF="http://natura.di.uminho.pt/~jj/perl/XML/">http://natura.di.uminho.pt/~jj/perl/XML/</A></PRE>
<P>Alberto Simoes &lt;<A HREF="mailto:albie@alfarrabio.di.uminho.pt">albie@alfarrabio.di.uminho.pt</A>&gt;</P>
<P>thanks to</P>
<PRE>
  Michel Rodriguez &lt;mrodrigu@ieee.org&gt;
  José Carlos Ramalho &lt;jcr@di.uminho.pt&gt;</PRE>
<P>
<HR>
<H1><A NAME="name">NAME</A></H1>
<P><CODE>lat1.pm</CODE> - module for unicode utf8 to latin1 translation</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
   $latin1string = lat1::utf8($utf8string)</PRE>
<P>
<HR>
<H1><A NAME="bugs">Bugs</A></H1>
<P>Translating the latin1 subset of unicode utf8 is very simples and needs no
tables.</P>
<P>If you need more complex translation, see the perl modules about unicode
and the <CODE>recode</CODE> command.</P>

</BODY>

</HTML>
